use std::collections::HashMap;

use regex::Regex;
use serde::{Deserialize, Serialize};

use crate::errors::{AppError, ErrorType};

#[derive(Debug, Serialize, Deserialize, Clone, Copy)]
#[serde(rename_all = "lowercase")]
pub enum FilterType {
    AllPass,
    BandPass,
    HighPass,
    HighShelf,
    LowPass,
    LowShelf,
    Notch,
    Peaking,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct FilterParams {
    pub id: String,
    pub frequency: f64,
    pub gain: f64,
    pub q: f64,
    #[serde(rename = "type")]
    pub filter_type: FilterType,
}

impl FilterParams {

    pub fn to_apo_line(&self) -> String {
        let mut tokens = vec![format!("Filter {}:", self.id), String::from("ON")];
        let fc = format!("{:.1}", self.frequency);
        let gain = format!("{:.1}", self.gain);
        let q = format!("{:.3}", self.q);
        let line = match self.filter_type {
            FilterType::AllPass => format!("AP Fc {} Hz Q {}", fc, q),
            FilterType::BandPass => format!("BP Fc {} Hz Q {}", fc, q),
            FilterType::HighPass => format!("HPQ Fc {} Hz Q {}", fc, q),
            FilterType::HighShelf => format!("HSC Fc {} Hz Gain {} dB Q {}", fc, gain, q),
            FilterType::LowPass => format!("LPQ Fc {} Hz Q {}", fc, q),
            FilterType::LowShelf => format!("LSC Fc {} Hz Gain {} dB Q {}", fc, gain, q),
            FilterType::Notch => format!("NO Fc {} Hz Q {}", fc, q),
            FilterType::Peaking => format!("PK Fc {} Hz Gain {} dB Q {}", fc, gain, q),
        };
        tokens.push(line);
        tokens.join(" ")
    }
}

#[derive(Debug, Default, Serialize, Deserialize, Clone)]
pub struct EqState {
    pub preamp: f64,
    pub filters: Vec<FilterParams>,
}

impl EqState {

    pub fn default() -> EqState {
        return EqState {
            preamp: 0.0f64,
            filters: vec![
                FilterParams { id: String::from("1"), frequency: 48.0, gain: 0.0, q: 1.0, filter_type: FilterType::Peaking },
                FilterParams { id: String::from("2"), frequency: 225.0, gain: 0.0, q: 1.0, filter_type: FilterType::Peaking },
                FilterParams { id: String::from("3"), frequency: 1067.0, gain: 0.0, q: 1.0, filter_type: FilterType::Peaking },
                FilterParams { id: String::from("4"), frequency: 5060.0, gain: 0.0, q: 1.0, filter_type: FilterType::Peaking }
            ]
        }
    }
    
    pub fn from_apo_raw(raw_apo_fmt: &str) -> Result<EqState, AppError> {
        let lines: Vec<&str> = raw_apo_fmt.split('\n').collect();
        Self::from_lines(&lines)
    }

    pub fn from_lines(lines: &Vec<&str>) -> Result<EqState, AppError> {
        let mut filters: Vec<FilterParams> = vec![];
        let mut preamp = 0.0f64;

        for line in lines {
            if line.contains("Channel") {
                return Err(err(String::from("Independent channel EQ is not currently supported")));
            }
            if line.contains("Preamp") {
                preamp = process_preamp_line(line)?;
                continue;
            }
            if line.contains("Filter") {
                let filter = process_filter_line(line)?;
                filters.push(filter);
                continue;
            }
        }

        Ok(EqState { preamp, filters })
    }

    pub fn to_apo(&self, disabled: bool) -> String {
        let mut lines: Vec<String> = vec![
            // "# GENERATED FILE, DO NOT MODIFY".to_string(),
            // "# generated by eq+".to_string(),
            // "# eq+schema v1 ".to_string()
        ];
        if disabled {
            lines.push(format!("#Preamp: {:.1} dB", self.preamp));
        } else {
            lines.push(format!("Preamp: {:.1} dB", self.preamp));
        }
        for filter in &self.filters {
            let line = if disabled {
                format!("#{}", filter.to_apo_line())
            } else {
                filter.to_apo_line()
            };
            lines.push(line);
        }
        lines.join("\n")
    }
}

fn process_preamp_line(line: &str) -> Result<f64, AppError> {
    let re = Regex::new(r"Preamp:\s*(?P<preamp>.+) dB").unwrap();
    let caps = match re.captures(line) {
        Some(c) => c,
        _ => return Err(err(format!("Malformed preamp line: {}", line)))
    };
    let preamp_str = caps.name("preamp").map(|mat| {  mat.as_str() }).unwrap();
    match preamp_str.parse::<f64>() {
        Ok(val) => Ok(val),
        Err(_) => Err(err(format!("Malformed preamp line (bad gain value): {}", line))),
    }
}

fn process_filter_line(line: &str) -> Result<FilterParams, AppError> {
    let mut filter = FilterParams { id: String::from(""), frequency: 1.0, gain: 0.0, q: 1.0, filter_type: FilterType::Peaking };

    let re = Regex::new(r"\s*Filter\s+(?P<id>\d+):\s*(?P<tokens>.+)\s*").unwrap();
    let caps = match re.captures(line) {
        Some(c) => c,
        _ => return Err(err(format!("Malformed filter line: {}", line)))
    };
    let raw_id = caps.name("id").map(|mat| { mat.as_str() }).unwrap();
    filter.id = String::from(raw_id);

    let mut tokens = caps.name("tokens").map(|mat| {
        Regex::new(r"\s+")
            .unwrap()
            .split(mat.as_str())
            .map(|f| { f.to_string() })
            .collect::<Vec<String>>()
    }).unwrap();

    if tokens.len() == 0 {
        return Err(err(format!("No params given for line: {}", line)));
    }

    tokens.reverse();

    while tokens.len() > 0 {
        let token = tokens.pop();
        let t = token.as_deref();
        match t {
            Some("ON") => {
                match tokens.pop() {
                    Some(f) => {
                        let ftype = process_filter_type(f.as_str())?;
                        filter.filter_type = ftype;
                    },
                    None => return Err(err(format!("Malformed filter line (missing values): {}", line)))
                }
            },
            Some("Fc") => {
                let freq = match tokens.pop() {
                    Some(f) => match f.parse::<f64>() {
                        Ok(f) => f,
                        Err(_) => return Err(err(format!("Malformed filter line (invalid frequency): {}", line)))
                    },
                    None => return Err(err(format!("Malformed filter line (missing values): {}", line)))
                };
                if match tokens.pop() {
                    Some(hz) => hz != "Hz",
                    _ => true
                } {
                    return Err(err(format!("Malformed filter line (missing or invalid values): {}", line)));
                }
                filter.frequency = freq;
            },
            Some("Gain") => {
                let gain = match tokens.pop() {
                    Some(g) => match g.parse::<f64>() {
                        Ok(g) => g,
                        Err(_) => return Err(err(format!("Malformed filter line (invalid gain): {}", line)))
                    },
                    None => return Err(err(format!("Malformed filter line (missing values): {}", line)))
                };
                if match tokens.pop() {
                    Some(db) => db != "dB",
                    _ => true
                } {
                    return Err(err(format!("Malformed filter line (missing or invalid values): {}", line)));
                }
                filter.gain = gain;
            },
            Some("Q") => {
                let q = match tokens.pop() {
                    Some(q) => match q.parse::<f64>() {
                        Ok(q) => q,
                        Err(_) => return Err(err(format!("Malformed filter line (invalid Q): {}", line)))
                    },
                    None => return Err(err(format!("Malformed filter line (missing values): {}", line)))
                };
                filter.q = q;
            },
            _ => continue
        };
    }

    Ok(filter)
}

fn process_filter_type(raw_filter_type: &str) -> Result<FilterType, AppError> {
    match raw_filter_type {
        "PK" => Ok(FilterType::Peaking),
        "LP"|"LPQ" => Ok(FilterType::LowPass),
        "HP"|"HPQ" => Ok(FilterType::HighPass),
        "BP" => Ok(FilterType::BandPass),
        "LS"|"LSC" => Ok(FilterType::BandPass),
        "HS"|"HSC" => Ok(FilterType::HighShelf),
        "NO" => Ok(FilterType::Notch),
        "AP" => Ok(FilterType::AllPass),
        _ => Err(err(format!("Unsupported filter type: {}", raw_filter_type)))
    }
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct FilterMapping {
    pub enabled: bool,
    pub eq: EqState,
}

impl FilterMapping {
    pub fn default() -> HashMap<String, FilterMapping> {
        let mut map: HashMap<String, FilterMapping> = HashMap::new();
        map.insert(
            "all".to_string(),
            FilterMapping {
                enabled: true,
                eq: EqState::default(),
            }
        );
        map
    }

    pub fn from_apo_raw(raw: &str) -> Result<HashMap<String, FilterMapping>, AppError> {
        let mut mappings: HashMap<String, FilterMapping> = HashMap::new();
        let lines = raw.split("\n");
        let device_grouping: Vec<Box<Vec<&str>>> = lines
            .fold(vec![], |mut acc, line| {
                if line.contains("Device:") {
                    acc.push(Box::from(vec![]));
                }
                match acc.last_mut() {
                    Some(a) => a.push(line.trim()),
                    None => {}
                }
                acc
            });
        
        for d in device_grouping {
            let mut enabled = true;
            let mut device_name = String::new();
            match d.first() {
                Some(device_line) => {
                    enabled = !device_line.starts_with("#");
                    device_name = device_line
                        .replace("Device: ", "")
                        .replace("#", "")
                        .trim()
                        .to_string();
                },
                None => {}
            }
            let eq = EqState::from_lines(&d)?;
            mappings.insert(device_name, FilterMapping { enabled, eq });
        }

        Ok(mappings)
    }
}

pub fn mapping_to_apo(mapping: &HashMap<String, FilterMapping>) -> String {
    let mut result = "# GENERATED FILE, DO NOT MODIFY\n# generated by eq+\n# schema v1\n".to_string();
    for (device, m) in mapping {
        let d = if m.enabled {
            format!("Device: {}", device)
        } else {
            format!("#Device: {}", device)
        };
        result += format!("{}\n{}\n", d, m.eq.to_apo(!m.enabled)).as_str();
    }
    result
}

fn err(msg: String) -> AppError {
    AppError { err_type: ErrorType::InvalidConfig, message: msg }
}

#[test]
fn test_filter_mapping() {
    let input = "
# GENERATED FILE, DO NOT MODIFY
# generated by eq+
# schema v1
Device: test-device {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
Preamp: -1.0 dB
Filter 1: ON PK Fc 55.0 Hz Gain 5.0 dB Q 1.0
Device: other device {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
Preamp: -5.0 dB
#Device: third device {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
#Preamp: -3.0 dB
#Filter 1: ON PK Fc 41.0 Hz Gain -5.0 dB Q 0.100
    ";

    let result = FilterMapping::from_apo_raw(input).unwrap();
    println!("{:?}", result);
    let first = result.get(&"test-device {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}".to_string()).unwrap();
    assert_eq!(first.enabled, true);
    assert_eq!(first.eq.preamp, -1.0f64);
    assert_eq!(first.eq.filters.first().unwrap().frequency, 55f64);

    let second = result.get(&"other device {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}".to_string()).unwrap();
    assert_eq!(second.enabled, true);
    assert_eq!(second.eq.preamp, -5.0f64);

    let third = result.get(&"third device {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}".to_string()).unwrap();
    assert_eq!(third.enabled, false);
    assert_eq!(third.eq.preamp, -3.0f64);
    assert_eq!(third.eq.filters.first().unwrap().frequency, 41f64);
    assert_eq!(third.eq.filters.first().unwrap().q, 0.1f64);

    let serialized = mapping_to_apo(&result);
    println!("{}", serialized);
}
