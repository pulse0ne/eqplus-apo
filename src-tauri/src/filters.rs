use regex::Regex;
use serde::{Deserialize, Serialize};

use crate::errors::{AppError, ErrorType};

#[derive(Debug, Serialize, Deserialize, Clone, Copy)]
#[serde(rename_all = "lowercase")]
pub enum FilterType {
    AllPass,
    BandPass,
    HighPass,
    HighShelf,
    LowPass,
    LowShelf,
    Notch,
    Peaking,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct FilterParams {
    pub id: String,
    pub frequency: f64,
    pub gain: f64,
    pub q: f64,
    #[serde(rename = "type")]
    pub filter_type: FilterType,
}

impl FilterParams {

    pub fn to_apo_line(&self) -> String {
        let mut tokens = vec![format!("Filter {}:", self.id), String::from("ON")];
        let fc = format!("{:.1}", self.frequency);
        let gain = format!("{:.1}", self.gain);
        let q = format!("{:.3}", self.q);
        let line = match self.filter_type {
            FilterType::AllPass => format!("AP Fc {} Hz Q {}", fc, q),
            FilterType::BandPass => format!("BP Fc {} Hz Q {}", fc, q),
            FilterType::HighPass => format!("HPQ Fc {} Hz Q {}", fc, q),
            FilterType::HighShelf => format!("HSC Fc {} Hz Gain {} dB Q {}", fc, gain, q),
            FilterType::LowPass => format!("LPQ Fc {} Hz Q {}", fc, q),
            FilterType::LowShelf => format!("LSC Fc {} Hz Gain {} dB Q {}", fc, gain, q),
            FilterType::Notch => format!("NO Fc {} Hz Q {}", fc, q),
            FilterType::Peaking => format!("PK Fc {} Hz Gain {} dB Q {}", fc, gain, q),
        };
        tokens.push(line);
        tokens.join(" ")
    }
}

#[derive(Debug, Default, Serialize, Deserialize, Clone)]
pub struct EqState {
    pub enabled: bool,
    pub preamp: f64,
    pub filters: Vec<FilterParams>,
}

impl EqState {

    pub fn default() -> EqState {
        return EqState {
            enabled: true,
            preamp: 0.0f64,
            filters: vec![
                FilterParams { id: String::from("1"), frequency: 48.0, gain: 0.0, q: 1.0, filter_type: FilterType::Peaking },
                FilterParams { id: String::from("2"), frequency: 225.0, gain: 0.0, q: 1.0, filter_type: FilterType::Peaking },
                FilterParams { id: String::from("3"), frequency: 1067.0, gain: 0.0, q: 1.0, filter_type: FilterType::Peaking },
                FilterParams { id: String::from("4"), frequency: 5060.0, gain: 0.0, q: 1.0, filter_type: FilterType::Peaking }
            ]
        }
    }
    
    pub fn from_apo_raw(raw_apo_fmt: &str) -> Result<EqState, AppError> {
        let lines = raw_apo_fmt.split('\n');
        let mut filters: Vec<FilterParams> = vec![];
        let mut preamp = 0.0f64;

        for line in lines {
            if line.starts_with("Channel:") {
                return Err(err(String::from("Independent channel EQ is not currently supported")));
            }
            if line.starts_with("Preamp:") {
                preamp = process_preamp_line(line)?;
                continue;
            }
            if line.starts_with("Filter:") {
                let filter = process_filter_line(line)?;
                filters.push(filter);
                continue;
            }
        }

        Ok(EqState { enabled: true, preamp, filters })
    }

    pub fn to_apo(&self) -> String {
        let mut lines = vec![
            "# GENERATED FILE, DO NOT MODIFY".to_string(),
            "# generated by eq+".to_string(),
            "# eq+schema v1 ".to_string()
        ];
        lines.push(format!("Preamp: {:.1} dB", self.preamp));
        for filter in &self.filters {
            lines.push(filter.to_apo_line());
        }
        lines.join("\n")
    }
}

fn process_preamp_line(line: &str) -> Result<f64, AppError> {
    let re = Regex::new(r"Preamp:\s*(?P<preamp>.+) dB").unwrap();
    let caps = match re.captures(line) {
        Some(c) => c,
        _ => return Err(err(format!("Malformed preamp line: {}", line)))
    };
    let preamp_str = caps.name("preamp").map(|mat| {  mat.as_str() }).unwrap();
    match preamp_str.parse::<f64>() {
        Ok(val) => Ok(val),
        Err(_) => Err(err(format!("Malformed preamp line (bad gain value): {}", line))),
    }
}

fn process_filter_line(line: &str) -> Result<FilterParams, AppError> {
    let mut filter = FilterParams { id: String::from(""), frequency: 1.0, gain: 0.0, q: 1.0, filter_type: FilterType::Peaking };

    let re = Regex::new(r"\s*(?P<id>Filter \d+):\s*(?P<tokens>.+)\s*").unwrap();
    let caps = match re.captures(line) {
        Some(c) => c,
        _ => return Err(err(format!("Malformed filter line: {}", line)))
    };
    let raw_id = caps.name("id").map(|mat| { mat.as_str() }).unwrap();
    filter.id = String::from(raw_id);

    let mut tokens = caps.name("tokens").map(|mat| {
        Regex::new(r"\s+")
            .unwrap()
            .split(mat.as_str())
            .map(|f| { f.to_string() })
            .collect::<Vec<String>>()
    }).unwrap();

    if tokens.len() == 0 {
        return Err(err(format!("No params given for line: {}", line)));
    }

    tokens.reverse();

    while tokens.len() > 0 {
        let token = tokens.pop();
        let t = token.as_deref();
        match t {
            Some("ON") => {
                match tokens.pop() {
                    Some(f) => {
                        let ftype = process_filter_type(f.as_str())?;
                        filter.filter_type = ftype;
                    },
                    None => return Err(err(format!("Malformed filter line (missing values): {}", line)))
                }
            },
            Some("Fc") => {
                let freq = match tokens.pop() {
                    Some(f) => match f.parse::<f64>() {
                        Ok(f) => f,
                        Err(_) => return Err(err(format!("Malformed filter line (invalid frequency): {}", line)))
                    },
                    None => return Err(err(format!("Malformed filter line (missing values): {}", line)))
                };
                if match tokens.pop() {
                    Some(hz) => hz != "Hz",
                    _ => true
                } {
                    return Err(err(format!("Malformed filter line (missing or invalid values): {}", line)));
                }
                filter.frequency = freq;
            },
            Some("Gain") => {
                let gain = match tokens.pop() {
                    Some(g) => match g.parse::<f64>() {
                        Ok(g) => g,
                        Err(_) => return Err(err(format!("Malformed filter line (invalid gain): {}", line)))
                    },
                    None => return Err(err(format!("Malformed filter line (missing values): {}", line)))
                };
                if match tokens.pop() {
                    Some(db) => db != "dB",
                    _ => true
                } {
                    return Err(err(format!("Malformed filter line (missing or invalid values): {}", line)));
                }
                filter.gain = gain;
            },
            Some("Q") => {
                let q = match tokens.pop() {
                    Some(q) => match q.parse::<f64>() {
                        Ok(q) => q,
                        Err(_) => return Err(err(format!("Malformed filter line (invalid Q): {}", line)))
                    },
                    None => return Err(err(format!("Malformed filter line (missing values): {}", line)))
                };
                filter.q = q;
            },
            _ => continue
        };
    }

    Ok(filter)
}

fn process_filter_type(raw_filter_type: &str) -> Result<FilterType, AppError> {
    match raw_filter_type {
        "PK" => Ok(FilterType::Peaking),
        "LP"|"LPQ" => Ok(FilterType::LowPass),
        "HP"|"HPQ" => Ok(FilterType::HighPass),
        "BP" => Ok(FilterType::BandPass),
        "LS"|"LSC" => Ok(FilterType::BandPass),
        "HS"|"HSC" => Ok(FilterType::HighShelf),
        "NO" => Ok(FilterType::Notch),
        "AP" => Ok(FilterType::AllPass),
        _ => Err(err(format!("Unsupported filter type: {}", raw_filter_type)))
    }
}

pub struct FilterMapping {
    pub device_name: String,
    pub eq: EqState,
}

impl FilterMapping {
    pub fn from_apo_raw(raw: &str) -> Result<Vec<FilterMapping>, AppError> {
        let mut mappings: Vec<FilterMapping> = vec![];
        let device_boundaries: Vec<usize> = raw.match_indices("Device:").map(|(i, _)| i).collect();
        for b in device_boundaries {
            println!("{}", b);
        }
        Ok(mappings)
    }
}

fn err(msg: String) -> AppError {
    AppError { err_type: ErrorType::InvalidConfig, message: msg }
}

#[test]
fn test_filter_mapping() {
    let input = "
    # something else
    Device: test-device {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
    Preamp: 0.0 dB
    Device: other device {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
    Preamp: 5.0 dB
    ";

    let _result = FilterMapping::from_apo_raw(input);

}
